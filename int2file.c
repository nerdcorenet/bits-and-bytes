/**
 * int2file.c - A program to convert arbitrarily long decimal integers
 * to raw binary data and write it to a file.
 *
 * This program requires the GMP library: http://libgmp.org/
 * and must be compiled with the "-lgmp" option.
 * 
 * Copyright (c) 2015 Mike Mallett <mike@nerdcore.net>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdio.h>
#include <stdlib.h> // For exit()
#include <libgen.h> // For basename()
#include <strings.h> // For strcmp()
#include "gmp.h" // Requires libgmp http://www.gmplib.org/

// These defines are used to determine, once, whether we are writing to
// or reading from the file specified on the command line.

#define _EXEC_FORM_UNKNOWN 0
#define _EXEC_FORM_INTFILE 1
#define _EXEC_FORM_FILEINT 2

void usage(int, char*);

int main (int argc, char *argv[]) {
  // Setup variables
  unsigned char *filename, *filemode;
  // tempfile is used to hold the value generated by mpz_out_raw()
  FILE *tempfile = tmpfile();
  FILE *file;
  unsigned int base, execform;
  char *cmd = basename(argv[0]);
  unsigned long length;

  if (strcmp(cmd, "int2file") == 0) {
    execform = _EXEC_FORM_INTFILE;
    filemode = "wb";
  } else if (strcmp(cmd, "file2int") == 0) {
    execform = _EXEC_FORM_FILEINT;
    filemode = "rb";
  } else {
    execform = _EXEC_FORM_UNKNOWN;
    usage(execform, cmd);
  }

  // Process command-line args
  if (argc < 2) {
    usage(execform, cmd);
  }

  // Open file
  filename = *(++argv);
  file = fopen(filename, filemode);
  if (file == NULL) {
    printf("Unable to open file %s\n", filename);
    exit(-1);
  }

  // Set the user-defined BASE, or default to 10 (decimal)
  if (argc > 1) {
    base = *argv[2];
  } else {
    base = 10;
  }

  mpz_t x;
  mpz_init (x);

  // Read STDIN into x
  mpz_inp_str (x, stdin, 0);

  // Write x as a single binary number
  mpz_out_raw(tempfile, x);

  // The call to mpz_out_raw() includes a prefix of 4 bytes
  // in order to make it readable by mpz_in_raw(). Here we
  // write it to tempfile, determine the size of tempfil minus 4,
  // and use this value to get the unsigned raw binary data
  // without a prefix/header.
  length = ftell(tempfile) - 4;

  // We need a place to store data from tempfile
  unsigned char holder[length+1];

  // Skip 4 bytes at the beginning of tempfile
  fseek(tempfile, 4, SEEK_SET);

  // Read all remaining data into holder
  fread(&holder, 1, length, tempfile);

  // Write the output file with the data from holder
  fwrite(&holder, 1, length, file);

  /* Unless the program is about to exit, do ... */
  //mpz_clear(x);

  fclose(file);
}

// Prints usage summary and exits
void usage(int execform, char* cmd) {
  switch (execform) {
  case _EXEC_FORM_INTFILE:
    printf("Usage: %s FILENAME\n\n", cmd);
    printf("  Read decimal integer input from the user via STDIN, and output the value as unsigned binary to FILENAME.\n");
    break;
  case _EXEC_FORM_FILEINT:
    printf("Usage: %s FILENAME [BASE]\n\n", cmd);
    printf("  Read FILENAME and display it on STDOUT as a single unsigned integer of base BASE.\n");
    printf("  BASE is optional. Default is base 10.\n");
    break;
  default:
    printf("This command recognizes its function based on the executable file name.\n");
    printf("Your command `%s` was not understood.\n", cmd);
    printf("Please execute this program as `int2file` or `file2int` for correct functionality.\n");
    break;
  }

  exit(0);
}
